-- Unit tests for subscripts functionality
local unicode = require('unicode-math.backends.unicode')

describe("Subscripts", function()
    describe("Basic Subscripts", function()
        it("should convert simple numeric subscripts", function()
            assert_equal(unicode.convert_to_unicode("x_2"), "x₂")
            assert_equal(unicode.convert_to_unicode("x_3"), "x₃")
            assert_equal(unicode.convert_to_unicode("y_4"), "y₄")
            assert_equal(unicode.convert_to_unicode("z_0"), "z₀")
        end)
        
        it("should convert braced numeric subscripts", function()
            assert_equal(unicode.convert_to_unicode("x_{2}"), "x₂")
            assert_equal(unicode.convert_to_unicode("y_{10}"), "y₁₀")
            assert_equal(unicode.convert_to_unicode("z_{123}"), "z₁₂₃")
        end)
        
        it("should convert letter subscripts", function()
            assert_equal(unicode.convert_to_unicode("x_n"), "xₙ")
            assert_equal(unicode.convert_to_unicode("a_i"), "aᵢ")
            assert_equal(unicode.convert_to_unicode("b_j"), "bⱼ")
            assert_equal(unicode.convert_to_unicode("f_k"), "fₖ")
        end)
        
        it("should convert braced letter subscripts", function()
            assert_equal(unicode.convert_to_unicode("x_{n}"), "xₙ")
            assert_equal(unicode.convert_to_unicode("a_{max}"), "aₘₐₓ")
            assert_equal(unicode.convert_to_unicode("f_{init}"), "fᵢₙᵢₜ")
        end)
        
        it("should handle subscript operators", function()
            assert_equal(unicode.convert_to_unicode("x_{+}"), "x₊")
            assert_equal(unicode.convert_to_unicode("x_{-}"), "x₋")
            assert_equal(unicode.convert_to_unicode("x_{=}"), "x₌")
            assert_equal(unicode.convert_to_unicode("x_{()}"), "x₍₎")
        end)
    end)
    
    describe("Common Mathematical Subscripts", function()
        it("should handle sequence indexing", function()
            assert_equal(unicode.convert_to_unicode("a_1, a_2, a_3"), "a₁, a₂, a₃")
            assert_equal(unicode.convert_to_unicode("x_{i+1}"), "xᵢ₊₁")
            assert_equal(unicode.convert_to_unicode("x_{n-1}"), "xₙ₋₁")
        end)
        
        it("should handle matrix indexing", function()
            assert_equal(unicode.convert_to_unicode("a_{ij}"), "aᵢⱼ")
            assert_equal(unicode.convert_to_unicode("M_{12}"), "M₁₂")
            assert_equal(unicode.convert_to_unicode("A_{mn}"), "Aₘₙ")
        end)
        
        it("should handle variable naming conventions", function()
            assert_equal(unicode.convert_to_unicode("x_{min}"), "xₘᵢₙ")
            assert_equal(unicode.convert_to_unicode("x_{max}"), "xₘₐₓ")
            assert_equal(unicode.convert_to_unicode("v_{initial}"), "vᵢₙᵢₜᵢₐₗ")
        end)
    end)
    
    describe("Mixed Super and Subscripts", function()
        it("should handle both superscripts and subscripts", function()
            assert_equal(unicode.convert_to_unicode("x_2^3"), "x₂³")
            assert_equal(unicode.convert_to_unicode("a_{n}^{2}"), "aₙ²")
            assert_equal(unicode.convert_to_unicode("f_{i}^{(k)}"), "fᵢ⁽ᵏ⁾")
        end)
        
        it("should handle order independence", function()
            assert_equal(unicode.convert_to_unicode("x^2_n"), "x²ₙ")
            assert_equal(unicode.convert_to_unicode("a^{k}_{ij}"), "aᵏᵢⱼ")
        end)
    end)
    
    describe("Subscript Helper Function", function()
        it("should convert individual characters correctly", function()
            assert_equal(unicode.to_subscript("0"), "₀")
            assert_equal(unicode.to_subscript("1"), "₁")
            assert_equal(unicode.to_subscript("2"), "₂")
            assert_equal(unicode.to_subscript("3"), "₃")
            assert_equal(unicode.to_subscript("4"), "₄")
            assert_equal(unicode.to_subscript("5"), "₅")
            assert_equal(unicode.to_subscript("6"), "₆")
            assert_equal(unicode.to_subscript("7"), "₇")
            assert_equal(unicode.to_subscript("8"), "₈")
            assert_equal(unicode.to_subscript("9"), "₉")
        end)
        
        it("should convert letters correctly", function()
            assert_equal(unicode.to_subscript("a"), "ₐ")
            assert_equal(unicode.to_subscript("e"), "ₑ")
            assert_equal(unicode.to_subscript("h"), "ₕ")
            assert_equal(unicode.to_subscript("i"), "ᵢ")
            assert_equal(unicode.to_subscript("j"), "ⱼ")
            assert_equal(unicode.to_subscript("k"), "ₖ")
            assert_equal(unicode.to_subscript("l"), "ₗ")
            assert_equal(unicode.to_subscript("m"), "ₘ")
            assert_equal(unicode.to_subscript("n"), "ₙ")
            assert_equal(unicode.to_subscript("o"), "ₒ")
            assert_equal(unicode.to_subscript("p"), "ₚ")
            assert_equal(unicode.to_subscript("r"), "ᵣ")
            assert_equal(unicode.to_subscript("s"), "ₛ")
            assert_equal(unicode.to_subscript("t"), "ₜ")
            assert_equal(unicode.to_subscript("u"), "ᵤ")
            assert_equal(unicode.to_subscript("v"), "ᵥ")
            assert_equal(unicode.to_subscript("x"), "ₓ")
        end)
        
        it("should handle multi-character strings", function()
            assert_equal(unicode.to_subscript("123"), "₁₂₃")
            assert_equal(unicode.to_subscript("ijk"), "ᵢⱼₖ")
            assert_equal(unicode.to_subscript("max"), "ₘₐₓ")
        end)
        
        it("should handle unsupported characters with fallback", function()
            assert_contains(unicode.to_subscript("q"), "_q")
            assert_contains(unicode.to_subscript("z"), "_z")
            assert_contains(unicode.to_subscript("@"), "_@")
        end)
    end)
    
    describe("Edge Cases", function()
        it("should handle empty subscripts", function()
            assert_equal(unicode.convert_to_unicode("x_{}"), "x")
            assert_equal(unicode.convert_to_unicode("y_{ }"), "y ")
        end)
        
        it("should preserve spacing in complex expressions", function()
            assert_equal(unicode.convert_to_unicode("x_2 + y_3"), "x₂ + y₃")
            assert_equal(unicode.convert_to_unicode("a_{n} b_{m}"), "aₙ bₘ")
        end)
        
        it("should handle subscripts with Greek letters", function()
            assert_equal(unicode.convert_to_unicode("\\alpha_1"), "α₁")
            assert_equal(unicode.convert_to_unicode("\\beta_{max}"), "βₘₐₓ")
        end)
        
        it("should handle complex nested expressions", function()
            assert_equal(unicode.convert_to_unicode("x_{i_j}"), "xᵢ_ⱼ")
            assert_equal(unicode.convert_to_unicode("a_{n+1}"), "aₙ₊₁")
        end)
    end)
    
    describe("Real-world Examples", function()
        it("should handle physics notation", function()
            assert_equal(unicode.convert_to_unicode("F_{net}"), "Fₙₑₜ")
            assert_equal(unicode.convert_to_unicode("v_{initial}"), "vᵢₙᵢₜᵢₐₗ")
            assert_equal(unicode.convert_to_unicode("E_k"), "Eₖ")
        end)
        
        it("should handle chemistry notation", function()
            assert_equal(unicode.convert_to_unicode("H_2O"), "H₂O")
            assert_equal(unicode.convert_to_unicode("CO_2"), "CO₂")
            assert_equal(unicode.convert_to_unicode("C_{6}H_{12}O_6"), "C₆H₁₂O₆")
        end)
        
        it("should handle mathematical sequences", function()
            assert_equal(unicode.convert_to_unicode("a_n = a_{n-1} + a_{n-2}"), "aₙ = aₙ₋₁ + aₙ₋₂")
            assert_equal(unicode.convert_to_unicode("\\sum_{i=1}^{n} a_i"), "∑[i=1→n] aᵢ")
        end)
    end)
end)